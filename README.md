# Bike_store
https://github.com/YadavBarkha/Bike_store/commit/e2949a66ba9e4c0b241b8381c59aecdf063ab500#r164487506


🚴‍♂️ Bike Store: Unlocking Insights for a Retail Business
📌 Project Overview

This project dives into the Bike Store relational database, focusing on sales, customers, products, inventory, and staff performance. Through structured SQL analysis and exploratory data techniques, it aims to reveal valuable insights that support retail strategy, customer engagement, and operational improvements.

🎯 Project Goals
🛒 Customer Insights

📌 Identify customer profiles, locations, and buying behavior.

📊 Analyze purchase patterns to enhance customer targeting and retention.

🚴 Product & Inventory Optimization

🛠️ Analyze stock levels across stores and categories.

🔍 Identify best-selling products and manage underperforming inventory.

💰 Revenue Enhancement

📈 Calculate total and category-wise revenue to spot trends.

🛍️ Evaluate pricing strategies and profit potential by product.

⚙️ Operational Efficiency

📌 Monitor staff involvement in orders and performance.

🗂️ Track store-wise sales to identify growth opportunities.

🛠️ Tools & Technologies Used

SQL – Core language for data querying and analysis

Bike Store Database (CSV/SQL) – Source data

MySQL / PostgreSQL – Query processing engines

DBeaver / MySQL Workbench – IDE for schema exploration and EDA

📊 Insights & Expected Outcomes

📢 Improved customer segmentation and personalized marketing.

🚲 Efficient inventory control based on demand and stock data.

💵 Increased revenue through smart product and store-level analysis.

📌 Data-driven staffing and operational decisions.

📁 Repository Structure
bike-store-sql-project/
│
├── data/
│ └── [brands.csv, products.csv, orders.csv, ...]
│
├── schema/
│ ├── bike_store_schema.sql
│ └── bike_store_er_diagram.png
│
├── queries/
│ ├── sales_analysis.sql
│ ├── customer_behavior.sql
│ ├── inventory_report.sql
│ └── staff_performance.sql
│
└── README.md

✅ Sample SQL Queries

Show all customers from the city 'New York'
select first_name,last_name,city
from customers
where city = 'New York';

Find the number of products in each category
SELECT category_id, COUNT(*) AS product_count
FROM products
GROUP BY category_id;

List all products with category, brand, and price
SELECT p.product_name, c.category_name, b.brand_name, p.list_price
FROM products as p
inner join categories as c ON p.category_id = c.category_id
inner jOIN brands as b ON p.brand_id = b.brand_id;

Show all orders along with customer name and order date
select o.order_id, c.first_name, c.last_name, o.order_date
from orders as o
inner join customers as c ON o.customer_id = c.customer_id;

Find the top 5 most expensive products
select product_name, list_price
from products
order by list_price desc
limit 5;

List products with no stock in any store
select p.product_name
from products as p
left join stocks as s on p.product_id = s.product_id
where s.quantity is null;

Get total revenue from each product
select p.product_name, SUM(oi.quantity * oi.list_price) as revenue
from order_items as oi
left join products p on oi.product_id = p.product_id
group by p.product_name;

Show order details with product names and quantity
select o.order_id, p.product_name, oi.quantity
from orders as o
inner join order_items as oi on o.order_id = oi.order_id
inner join products as p on oi.product_id = p.product_id;

List all staff and the number of orders they handled
select s.staff_id, s.first_name, s.last_name, COUNT(o.order_id) as total_orders
from staffs s
left join orders o on s.staff_id = o.staff_id
group by s.staff_id, s.first_name, s.last_name;

Revenue generated per category
select c.category_name, SUM(oi.quantity * oi.list_price) as total_revenue
from order_items as oi
inner join products p on oi.product_id = p.product_id
inner join categories c On p.category_id = c.category_id
group by c.category_name
order by total_revenue desc;

Total stock available in each store
select st.store_name, SUM(s.quantity) as total_stock
from stocks as s
inner join stores as st On s.store_id = st.store_id
group by st.store_name;

Revenue generated by each store
select st.store_name, SUM(oi.quantity * oi.list_price) as store_revenue
from orders as o
JOIN order_items oi on o.order_id = oi.order_id
inner join staffs s on o.staff_id = s.staff_id
inner join stores st on s.store_id = st.store_id
group by st.store_name
order by store_revenue desc;

Most sold product by quantity
select p.product_name, SUM(oi.quantity) as total_quantity
from order_items as oi
join products as p on oi.product_id = p.product_id
group by p.product_name
order by total_quantity desc
limit 1;

Most profitable product (based on revenue)
select p.product_name, SUM(oi.quantity * oi.list_price) as total_revenue
from order_items as oi
inner join products as p on oi.product_id = p.product_id
group by p.product_name
order by total_revenue desc
limit 1;

Percentage contribution of each category to total revenue
select c.category_name,
ROUND(SUM(oi.quantity * oi.list_price) * 100.0 /
(select SUM(quantity * list_price) from order_items), 2) as revenue_percentage
from order_items as oi
inner join products as p on oi.product_id = p.product_id
inner join categories as c ON p.category_id = c.category_id
group by c.category_name;

📌 Conclusion

This project highlights the potential of SQL-driven business intelligence in the retail sector. From optimizing product inventory to tracking staff productivity and enhancing revenue through analytics, the Bike Store Database provides a practical, hands-on environment for applying real-world data skills.
